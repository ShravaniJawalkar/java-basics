Q1: What is Spring Security, and what problems does it solve in a Spring Boot application?

provide mechanism to add authentication and authorization to spring boot application.
it secure the application from various security attack(CQRS,XXS,Sql Injection,CORS)
and it secure our microservice architecture application. and rest endpoints.
it secure endpoint with rol/permission based access
secure client credentials and session.

Q2: How do you set up Spring Security in a Spring Boot application?
using spring-boot-starter-security dependency in maven/gradle.and @EnableWebSecurity on app config class.
1-by default it provide authentication by using login page with generated password in console.
2 -we can provide our own user name password in Application.properties file.
SecurityFilterChain invoke UserDetailsAuthenticationFilter which use AuthenticationManager -> ProviderManager
-> ApplicationProvider-> DaoBaseAuthenticationProvider -> PasswordEncoder and UserDetailsService to authenticate user.
UserDetailsService is interface which call InMemoryUserDetailsManager  for default configuration.
3- we can create UserDetailService bean in config . create  different user using User builder which return UserDetails and pass it to Object of InMemoryUserDetailManager.
4- instead of using memoryUserDetailManager We can use JdbUserDetailManager to store user in DB and access user from DB. recommended approach for production.

PasswordEncoder bean to encode password.
DelegatingPasswordEncoder to support multiple encoding mechanism.
BcryptPasswordEncoder -
AbstractPasswordEncoder -
NoOpPasswordEncoder - not recommended for production.
here we can use {noop},{bcrypt} in password identity so password encoder invoke delegating password encoder which delegate request to respective password encoder.
else we can explicitly register bean in AppConfig class.

Q3: What are the default configurations provided by Spring Security?
default random generated Password in console.(this is generated by InMemoryUserDetailManager which internally creat User(implements UserDetails) object. in User Object default password is set to random generator.)
provide default login page.
By default it secure all the endpoints.
by default it enable CSRF token for web pages. but disable for rest api.

Q4: What is the difference between authentication and authorization?
authentication- does user has valid credentials to login to application.
authorization - does user has valid role/permission to access the resource.
In Spring Security authentication is handled by
AuthenticationManager
LDAP AuthenticationProvider
Database AuthenticationProvider
Authorization is handled by setting role/permission on endpoint using

What is the role of SecurityFilterChain in Spring Security?
it authenticate the request coming to any request endpoint.
public SecurityFilterChain filterChain (HttpSecurity http) throws Exception {
http.authorizeHttpRequest(authorizeRequest->{authorizeRequest.requestMatchers("/login").permitAll()
.requestMatchers("/admin").hasRole("ADMIN").anyRequest().authenticated()})
.csrf(Csrf -> csrf.disable()).formLogin(withDefaults()).sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

How does Spring Security handle authentication?
it uses AuthenticationManager which use ProviderManager to authenticate user by UserDetailService.

How does Spring Security handle password encryption?
By using PasswordEncoder interface and its implementation class.
It has DelegatingPasswordEncoder which Delegate password request to respective password encoder.
such as BcryptPasswordEncoder, NoOpPasswordEncoder(not recommended for production), Pbkdf2PasswordEncoder, SCryptPasswordEncoder etc.
passwordEncoder.matches(rawPassword, encodedPassword) method to match the password.

Q8: What is CSRF, and how do you handle it in Spring Security?
CSRF - cross site request forgery attack.. here attacker access the authenticated user token and use it to send request to server.
to avoid this we can use CSRF token user will send the CSRF token in request header or as hidden field in form. which is only available to authenticated user.
by default in spring security csrf is enabled for web application and need to disable for rest api because this are stateless.

Q9: How do you implement role-based access control in Spring Security?
using hasRole and hasAuthority method on endpoint to provide role/permission based access.

Q10: How does Spring Security manage authentication for stateless REST APIs?
using BasicAuthentication which is stateless but each time User need to pass authentication token in request header.
this token is generated by encoding user name and password in base64 format.
using JWT token based authentication. where user get JWT token after successful login and need to pass this token in request header for subsequent request.
FIst implement JWTAuthenticationTokeFilter which will intercept login request and pass it to AuthenticationManager
which then pass to providerManager -> AuthenticationProvider -> we need to Create Custom JWTAuthenticationProvider which will implement AuthenticationProvider interface
and override authenticate method to validate user and generate JWT Token we need to Create JwtAuthenticationToken which implements AbstractAuthenticationToken.
and in JwtAuthenticationProvider we need to override support method and Pass JwtAuthenticationToken.class

Q11: How do you implement JWT (JSON Web Tokens) with Spring Security?
create JwtValidationFilter which have the instance of JwtService to validate the token.

in filter we will override and implement doFilterChain method
extract jwt token
validate the token
if success
store in SecurityContextHolder
SecurityContextHolder.getContext().setAuthentication(authenticatedToken);

JwtAuthenticationTokenFilter extends OncePerRequestFilter - generating token
JwtAuthenticationToken extends AbstractAuthenticationToken - token object
JwtAuthenticationProvider implements AuthenticationProvider - validate user and generate token
override and implements authenticate and support method.
JwtValidationFilter extends OncePerRequestFilter - validate token in each request
JwtRefreshTokenFilter extends OncePerRequestFilter - generate new token if old token is about to expire.

Q12: A client wants to allow login only for a specific IP range. How would you implement this in Spring Security?
SpringSecurityFilterChain

create a custom IpFilter which extends OncePerRequestFilter
create list of Ip range which not allowed
in method doFilterInternal validate if clientIp( request.getRemoteAddress()) present in not allowed list if yest then throw forbidden exception else pass the request doFilter

Q13: How do you secure an application supporting both APIs and web login?
separate security filter chain bean for rest api and web login.
@Bean
public SecurityFilterChain apiLogin(HttpSecurity http) throws Exception {
http.authorizeHttpRequest(authorizeRequest->{authorizeRequest.requestMatchers("/api/*").anyRequest().authenticated();})
}
@Bean
public SecurityFilterChain webLogin(HttpSecurity http) throws Exception {
http.authorizeHttpRequest(authorizeRequest->{authorizeRequest.requestMatchers("/login").permitAll()
.requestMatchers("/register").permitAll().anyRequest().authenticated();})

Q14: What are some best practices for securing a Spring Boot application?
for Rest api use Jwt token
Use BcryptPasswordEncoder for password encoding.
disable CSRF and mentioned sessionCreationPolicy.STATELESS for rest api.
use role base access control.
use permitAll for public endpoint like login,register.
and use authenticated for secured endpoint.
use HTTPS to encrypt traffic
implement rate limiting to prevent brute force attack.
enable spring actuator for monitoring and alerting.

Q15: What happens if the Spring Security context is not properly cleared in asynchronous requests?

SecurityContextHolder has authentication object per user login. in synchronous communication it is created and managed and cleared by
SpringSecurityContextManagementFilter operate within the life cycle of http request.
in case of asynchronous communication like @async ,completableFuture, taskExecutor etc there are multiple threads involved to serve the HTTP request concurrently.
due to it's limitation that it operate within http life cycle it will not able to manage security context outside that so here we need to explicitly clear the securityContextHolder after authentication of httpRequest.

other wise it will have issues
Thread pollution (Stale Authentication object in ThreadLocal)
in async communication if user a has been authenticated and the securityContextHolder storing authentication object of User A which use ThreadLocal.
and if same thread from thread pool is reuse by user b then thread local data
can be shared to another User B as User a authentication object is not cleared properly. then its role and permission can be used by User B.
which can lead to security breach.
Memory Leak- if securityContextHolder is not cleared properly after authentication it will keep on adding authentication object in ThreadLocal


